---
title: Getting Started with Access Monitoring
description: Learn how to use Access Monitoring.
---

Access Monitoring is a powerful tool to understand and analyze the access patterns in your Teleport cluster.
This guide will help you understand how to use Access Monitoring to monitor access to resources in your Teleport cluster.

## Prerequisites
- Teleport v14 or later.
- For Self-Hosted Teleport the [AWS Athena Backend](../reference/backends.mdx#athena) is required.


### Configuration

<Tabs>
<TabItem scope={["enterprise", "oss"]} label="Self-Hosted">

To enable Access Monitoring you need to update the Teleport Auth Service configuration:
```yaml
auth_service:
  access_monitoring:
    enabled: true
    # AWS role ARN that Teleport will assume to execute Athena SQL queries.
    role_arn: arn:aws:iam::111111111111:role/access-monitoring-role
    # S3 bucket where Access Monitoring reports will be stored.
    report_results: s3://audit-long-example/report_results
```

</TabItem>
<TabItem scope={["cloud","team"]} label="Cloud-Hosted">

Teleport Access Monitoring is enabled by default for all Teleport Cloud users.

</TabItem>
</Tabs>


## Access Monitoring RBAC Permissions

To access the Access Monitoring interface, a user must have a role that allows
`list`, `read` and `use` verbs on the `security_report` and `audit_query` resources.
The preset `auditor` role has these permissions by default. Alternatively, you can create a custom role with these permissions:
```yaml
kind: role
metadata:
  name: my-role
spec:
  allow:
    rules:
    - resources:
      - security_report
      - audit_query
      verbs:
      - list
      - read
      - use
```

## Query Editor

The Query Editor in Teleport Access Monitoring provides users with a powerful interface to interactively query audit logs and generate insightful reports.
It offers a user-friendly environment for constructing SQL queries tailored to specific use cases,
Users can write custom SQL queries for these views to build custom reports akin to querying a relational database.

Within the Query Editor, users have access to a number of SQL views representing audit events captured by Teleport.
Below is a list of the available SQL views:

```
access_list_create
access_list_delete
access_list_member_create
access_list_member_delete
access_list_member_update
access_list_review
access_list_update
access_request_create
access_request_review
auth
bot_join
cert_create
db_session_query
db_session_query_failed
db_session_start
device_authenticate
device_enroll
exec
instance_join
join_token_create
kube_request
lock_created
lock_deleted
recovery_code_used
reset_password_token_create
saml_idp_auth
session_command
session_join
session_rejected
session_start
user_create
user_login
user_password_change
windows_desktop_session_end
windows_desktop_session_start
```

To access the Query Editor, navigate to the `Access Monitoring` section in the Teleport UI and click on the `Query Editor` tab.

### SQL query examples

- Query for unique users who executed a ssh command involving `/etc/passwd` file in some way:
```sql
SELECT
  DISTINCT user
FROM
  exec
WHERE
  command LIKE '%/etc/passwd%';
```

![exec passwd](../../img/access-monitoring/exec_passwd.png)

- Select the count of unique IP addresses associated with each user cert over different event dates:
```sql
SELECT
  event_date,
  identity_user AS user,
  COUNT(DISTINCT cert_create.identity_client_ip) AS unique_ip_count
FROM
  cert_create
GROUP BY
  event_date,
  identity_user
ORDER BY
  event_date;
```


- Selects users who interacted with the Teleport cluster from more than one different IP address:
```sql
SELECT * FROM (SELECT
  event_date,
  identity_user AS user,
  COUNT(DISTINCT cert_create.identity_client_ip) AS unique_ip_count
FROM
  cert_create
GROUP BY
  event_date,
  identity_user
ORDER BY
  event_date) AS data WHERE unique_ip_count > 1;
```

- Show all the unique IP addresses that were used by the user 'admin-annie':
```sql
SELECT
  DISTINCT identity_client_ip
FROM
  cert_create
WHERE identity_user = 'admin-annie'
```

- Show access requests and their reviews:
```sql
SELECT
  *
FROM
  access_request_create, access_request_review
WHERE
  access_request_create.id = access_request_review.id
```

- Show details about access request and review:
```sql
SELECT
  request.user, request.reason, request.roles, request.resource_ids, review.reviewer, review.state
FROM
  access_request_create as request, access_request_review as review
WHERE
  request.id = review.id
```


### Query Examples with Assist AI

The query editor also integrates with Teleport Assist, making it easy to generate queries with a human-readable description of the data you want to retrieve.

![assist query](../../img/access-monitoring/assist_query_1.png)


Teleport Assist will generate the SQL query based on the user prompt message:
![assist query result](../../img/access-monitoring/assist_query_2.png)

# Access Monitoring Reports
Access Monitoring provides a number of pre-built reports:

## Privileged Access Report
    The `Privileged Access Report` reports offers valuable insight into identifying weak security events across infrastructure.
    The report allows to identify the following weak security events:

### Database sessions with weak security

Following query identifies database sessions with weak security
such as as sessions with missing access requests, MFA, impersonation, and trusted device identification.

```sql
SELECT
    event_date,
    count(*) as count,
    user
FROM
    db_session_start
WHERE
    CARDINALITY(access_requests) IS NULL
AND
    with_mfa IS NULL
AND
    impersonator IS NULL
AND
    trusted_device_device_id IS NULL
GROUP BY
    event_date,
    user
ORDER BY
    event_date
```

![privileged access report](../../img/access-monitoring/privileged_access_report.png)


**Suggestion:**  Setup access requests, device trust and per-session MFA.

### SSH sessions with weak security

Following query identifies SSH sessions with weak security,
such as as sessions with missing access requests, MFA, impersonation, and trusted device identification.

```sql
SELECT
    event_date,
    count(*) as count,
    user
FROM
    session_start
WHERE
    CARDINALITY(access_requests) IS NULL
AND
    proto='ssh'
AND
    with_mfa IS NULL
AND
    impersonator IS NULL
AND
    trusted_device_device_id IS NULL
GROUP BY
    event_date,
    proto,
    user
ORDER BY
    event_date
```

**Suggestion:**  Setup access requests, device trust and per-session MFA.

### Kubernetes API calls with weak security

Following query identifies Kubernetes sessions with weak security,
such as sessions with missing access requests, MFA, impersonation, and trusted device identification.

```sql
SELECT
    event_date,
    count(*) as count,
    user
FROM
    kube_request
WHERE
    CARDINALITY(access_requests) IS NULL
AND
    with_mfa IS NULL
AND
    impersonator IS NULL
AND
    trusted_device_device_id IS NULL
GROUP BY
    event_date,
    user
ORDER BY
    event_date
```

**Suggestion:**  Setup access requests, device trust and per-session MFA.

### Privileged Postgres sessions

Following query identifies privileged PostgreSQL sessions initiated by the 'postgres' user.

```sql
SELECT
	event_date,
	COUNT(*) AS count,
	user
FROM
    db_session_start
WHERE
    db_protocol='postgres' and db_user='postgres'
GROUP BY
    event_date,
    user
ORDER BY
    event_date
```

**Suggestion:** Downgrade database connections to less privileged database user.

### Kube Execs

Following query identifies Kubernetes exec usage.

```sql
SELECT
    event_date,
    count(*) as count,
    user
FROM
    exec
WHERE
    proto='kube'
GROUP BY
    event_date,
    proto,
    user
ORDER BY
    event_date
```

**Suggestion:**  Eliminate usage of kube exec.


### Long lived certificates

Following query identifies long-lived certificates, where the certificate expiration time is greater than 1 day.

```sql
SELECT DISTINCT
    event_date,
    COUNT(*) AS count,
    identity_user AS user
FROM
    cert_create
WHERE
    from_iso8601_timestamp(identity_expires) - from_iso8601_timestamp(time) > INTERVAL '1' DAY
GROUP BY
    event_date,
    identity_user
ORDER BY
    event_date
```

**Suggestion:**  Use short lived certificates less than a working day. Check out Machine ID to get short lived certificates for your automation.

### Long-lived join tokens

Following query identifies long-lived join tokens where the token expiration time is greater than 1 day.

```sql
SELECT
    event_date,
    COUNT(*) as count,
    node_name,
    host_id
FROM
    instance_join
WHERE
    FROM_ISO8601_TIMESTAMP(token_expires) - FROM_ISO8601_TIMESTAMP(time) > INTERVAL '1' DAY
GROUP BY
    event_date,
    node_name,
    host_id
ORDER BY
    event_date
```

**Suggestion:**  Use short-lived tokens to reduce risk of compromise or AWS/GCP/Azure joining when possible.

### Root SSH sessions

Following query identifies SSH sessions initiated by the 'root' user.

```sql
SELECT
    event_date,
    COUNT(*) as count,
    user
FROM
    session_start
WHERE
    login='root'
GROUP BY
    event_date,
    user
ORDER BY
    event_date
```
**Suggestion:**  Donâ€™t use `root` for SSH sessions, downgrade access to users with sudo privileges instead.

### System Kubernetes API calls

Following query identifies Kubernetes API calls initiated by users in the 'system:master' group.

```sql
SELECT
	event_date,
	COUNT(*) as count,
	user
FROM
    kube_request
WHERE
    CONTAINS(kubernetes_groups, 'system:masters')
GROUP BY
    event_date,
    user
ORDER BY
    event_date
```

**Suggestion:**  Don't use system:masters group for Kubernetes API calls, downgrade to `view` or `edit` instead.